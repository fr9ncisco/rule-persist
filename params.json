{"name":"Rule-persist","tagline":"","body":"# rule-persist\r\n\r\nDrools \"rules\" persistence on DB as is without KieWorkbench\r\n\r\n## Goals\r\n- Avoid drools maven scheme dependencies at runtime\r\n- Avoid KieWorkbench component\r\n- Allow hot deployement without runtime automated update\r\n- Use versioning information for sets of rules\r\n- Avoid changing rule execution API schemes\r\n\r\n\r\n## Context\r\nA Drools 6.xx Rule project is made of :\r\n- a Pom.property file, containig GAV(groupid,artefactid, versionid ) information.\r\n- a KieModule file :  A  description of components and their configuration that will be used at runtime.\r\n- Rule artefact files : rules, decision tables, rule process flows, etc...\r\n- dependencies to java models referenced in rules(no files)\r\n\r\nCommon development usage of Drools is to produce an archive containing those files so that this archive can be used at runtime to execute rules contained in it.\r\n\r\nDrools uses Maven in its core for building and deployement scheme of rule archives:  \r\nWhenever a new ruleset archive is produced, it may be deployed on the local Maven repository of an Application server, in order to be used and eventually update application behavior.   \r\nRisk of a human error or misusage has been raised, and implies that the use of maven on a runtime server should be avoided and that a more secure and non automated solution unlike maven should be used instead, in order to update rules.  \r\nAlthough, the usage of drools for developement, deployement, usage and update should remain simple.\r\n\r\n\r\n## Drools  mechanisms\r\nDrools since version 6.x uses a new set of APIs.  \r\nMaven has been placed in the core of the Rule Engine for its lifecycle(build, runtime, update) \r\n\r\nMaven style archives are :\r\n- produced by the build process.\r\n- used at runtime to load rule sets\r\n- used ar runtime to update rule sets\r\n\r\nIt is necessary to present core concepts, in order to show how they may be used without maven.\r\n\r\nRuntime behaviour of rule execution and acess is described through an XML file : kiemodule.xml.   \r\nIn this xml file, some drools components are defined such as :\r\n- KieContainer\r\n- KieBase\r\n- KieSession\r\n\r\n## 1 : KieContainer\r\nTo model a set of rules, a KieContainer is used.\r\nat runtime and is configured with the help of kiemodule.xml file.\r\n\r\nRules are not declared upfront in the file, they are declared throug groups\r\n\r\nA KieContainer contains a set of rules : any kind of rule artifacts, whether there are contained in one or many files.  \r\nA KieContainer supports versioning information : It holds versionning informations that are set like maven style.  \r\nA KieContainer can be updated at runtime with new rules though a special set of drools components.  \r\n\r\nA KieContainer can be updated from a JAR file, and the content of this JAR file must follow some contraints :   \r\n- a kmodule.xml, describing the grouping of rules into packages, the access of rule groups through knowledge bases and sessions.\r\n- Rules artifacts are contained into this file.\r\n\r\n## 2 : KieBase\r\nThe scope of a KieBase is declared within a KieContainer scope and multiple KieBases can be defined in a single KieContainer scope.   \r\nA kieBase defines one or more groups of rule artefacts using packages property. This is the only way to define rule selection for a KieBase using package names because rule artifact have to define a package name they belong to.  \r\n\r\nA KieBase may reference one or more Kiebase as well, thus inheritating its/their rules grouping.   \r\nIn order to distinguish a KieBase from another one, it is necessary to provide a unique name to a KieBase.  \r\n\r\n## 3 : KieSessions\r\nA KieSession is defined within the scope of a KieBase. Generally only one session is defined.  \r\nMutiple properties may be defined within the KieSession scope such as:\r\n- a name  : unique within the KieBase scope and preferably among the KieContainer scope.\r\n- Session type : Stateless or Statefull\r\n- ...\r\n\r\n## 4 : Rule Artifacts\r\nRule artifacts may be of many kinds :\r\n- Ruleflow process file : format = xml.\r\n- Decision table : format = xls, csv\r\n- Technical Rule : drl.\r\n\r\nThese file have always a package information. Rules are grouped logically per package information, that are used in KieBase defintions.   \r\n\r\nOther file may be used but are primarely used on KieWorkbench(web interface : BRMS)\r\n\r\n\r\n\r\n\r\n## Steps that needs to be performed in any case\r\n\r\n### 1. Describing archives :\r\nArchives need to be described in order to know how to build versionned rule archives \r\n- Description is performed by kieModule.xml file: KieContainer, KieBase, KieSession.   \r\n-- packages and rule artefacts referencing these packages   \r\n- Versionning information is done with the help of pom.properties   \r\n\r\n### 2. Building archives : \r\nRule archives are usually built with maven, but they can also be built using Java Drools API.\r\nThe result is a JAR file containing a kiemdule.xml\r\n\r\n\r\n### 3. Deploying archives : \r\nRule archives must be in the classpath so that they can be found. \r\nWhen rules are deployed with the help of Maven on a local Maven repository, they can be used and found, by underlying maven framework layer used by Drools.\r\n\r\n### 4. Using archives : running rules\r\nAt startup time, Drools looks up for JAR files containing a kiemodule.xml file, parses them.\r\nVersionned Rule archives must be available to Runtime platform so that rule engine may use them.\r\nA special mechanism may be used with the help of Maven driven by drools to enable hot deployment: \r\n- Whenever a new archive is deployed on the local maven repository   \r\n- maven-metadata-local.xml is updated with new deployed version   \r\n** A kieScanner is used to monitor modifications of this file on a frequency based period , so that it updates the KieContainer with newly deployed version according to maven updates set properties and the period.   \r\n** Its is possible to use a JMX console to update any instantiated KieContainer, with the latest Rule Archive deployed with maven. But this action needs to be performed on every KieContainer...\r\n\r\n# Solution\r\n\r\nDrools customization needs to be performed :   \r\n- Building : In order to build archives, a different mechanism has to be used so that maven is not in the way\r\n- Building will not be performed using maven plugins, but with Java code.\r\n- Drools Java API will provide this buidling, but kiemodule.xml and pom.properties have to be generated.\r\n- Rules have to be discovered where they are hosted(GIT).\r\n- Rule Archives will be stored on DB instead of local maven repo.\r\n- JMX will be used to perform any updates : security based actions, on demand.\r\n- JMX will allow to read DB and update in memory Rule archive repository\r\n- JMX will allow to udpate KieContainer(s) with new Rule archives\r\n- Rule services will need to register themselves to JMX service manager so that they can be updated when needed.\r\n\r\n## Property based description of KieContainer : a Module.\r\nIn order to describe rule projects, a property file based will provide a simple way to perform this task :   \r\nmodules.properties   \r\nA special parsing is done to allow comma separated values properties and dynamic naming.\r\n\r\nThis file describes all modules that are to be built, their GAV information, and their bases and sessions.\r\n\r\nFollowing is a sample of a modules.properties file,  describing a single module with a single base and a single session.\r\n```Ini\r\n# list of modules to generate\r\nall.modules = module1\r\n\r\n# module generated jar version\r\nmodule1.versionid=1.0.0-SNAPSHOT\r\nmodule1.groupid=com.acme.drools.tools\r\nmodule1.artefactid=dealviewtimeline\r\n\r\n# module1 description\r\nmodule1.bases=hello_base \r\nmodule1.hello_base.packages=hello_rules \r\nmodule1.hello_base.session=hello_session \r\nmodule1.hello_base.hello_session.type=Stateless \r\n\r\n```\r\n\r\nJava class : ModulePropertyLoader allows to parse this propety file in order to generate a composition of modules , bases and sessions.\r\n\r\nThe result of modules correctly parsed are available as well as errors during parsing process.\r\n\r\n## Git artefact loading :    \r\nNow that modules are described , it is possible to get Rules artefact files from SCM : i.e. GIT   \r\nFor that purpose, a GitRuleLoader Java class has been done for that purpose.\r\n\r\nThis class is able to retreive a remote repository GIT file structure as a Bare repository, make a local repository copy and extract rules associated with package, obtained through navigation withing module.base hierarchy.\r\n\r\n## Archive building :    \r\nAs rule artefacts are available, it is time to build rule archive.    \r\nOne requirement is to have runtime model classes used in rule available so that rule compiling is possible.\r\n\r\nMduleBuilder java class is ment for that purpose and allows to generate all required files : kieModule.xml, pom properties, and java artefacts in a JAR file, into a specific folder.\r\n\r\n## Archive deployment :    \r\n Deployment is achieved through a set of java classes, allowing persistance using a persistence service, a DAO pattern and a persistence model.\r\n \r\n\r\n## Runtime rule availability :\r\n Application has the responsability to load rules, that is to say instaciate KieContainer with proper GAV information.   \r\n Later on it can use those KieContainer and create named KieSessions.\r\n Although KieBase could be used it is not necessary to instantiate Object from this class.\r\n \r\n In order to load rules, a JMX Component is used and registered for the application VM : JmxModuleManager\r\n Through this MXBean, the application can retreive JARed modules and load them in Drools repository so that KieContainer.\r\n Upon request, the JmxModuleManager will download from database, all new JARed module newly deployed.\r\n \r\n A rule service using a KieContainer has to register itself to another MXBean with JMX : ServiceManager   \r\n This class upon request through JMX will get all loaded modules and update all registered RuleServices KieContext with latest JARed module related to this servcice.\r\n \r\n To Sum up : \r\n To update an application with new Rules : \r\n - deploy a new Archive to DB\r\n - Through JMX, reload all DB persisted modules.\r\n - Through JMX, update all Ruleservices.\r\n \r\n All thoses steps can be done via API, or even Oracle JConsole as JMX management tool.\r\n\r\n\r\n# Implementation\r\n\r\nOverall there is 4 projects:\r\n- One model Project : ModuleModel\r\n- One rule archive building project : ModuleArchiver\r\n- One Maven plugin building project  : ModuleArchiverMavenPlugin\r\n- One Runtime project : ModuleRuntime\r\n\r\n\r\n## ModuleModel\r\nThis project holds the model used almmost in every project.\r\n\r\n## ModuleArchiver\r\nThis project is responsible for \r\n- Parsing a property file with module, bases, packages and session descriptions\r\n- Cloning remotes GIT respositories, and fecthing on cloned repository rulefiles\r\n- Compiling rules modules and generating rule archives\r\n\r\n## ModuleArchiverMavenPlugin\r\nThis project is responsible for regrouping ModuleArchiver project under a unique humbrella in order to automate with Maven the building of Rule Archives\r\n\r\n## ModuleRuntime\r\nThis project is responsible for defining the use of rule archives :\r\nHow to store on DB a rule Archive\r\nHow to retreive a rule archive\r\nHow to deploy a rule archive\r\n\r\nAs well it offer services to eanble the use of Rule archives at runtime for any ruleservice that would be implemented though the use of JMX, in order to protect deployement(hot deployement) and decorelate deployement from building.\r\n\r\n\r\n \r\n \r\n \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}